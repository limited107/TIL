# Part 1 기반 다지기
* 작성하고 싶은 테스트 모습과 그렇게 만들고 싶은 이유를 생각할 수 있다.
* 테스트 더블을 이해할 수 있다.
* 2, 3부에서는 실무에 바로 활용할 수 있는 기술을 배운다.

----- 

* 1장 
	- 테스트를 작성해서 얻을 수 있는 이점이 무엇인가?
	- 프로그래머 생산성에 영향을 주는 요소와 테스트와 테스트 품질이 미치는 영향은?
	- 테스트 주도 개발(TDD), 행위 주도 개발(BDD)

* 2장
	- 좋은 테스트는 무엇인가? (가독성, 유지보수성, 신뢰성)
	- 원치 않는 모습의 테스트 예시

* 3장
	- 테스트 더블로 코드를 격리 
	- 테스트 더블의 종류와 차이점
	- 테스트 더블의 장점 살리기

## 1.1 좋은 테스트의 약속 
* 단위 테스트의 가치 
* 개발자 생산성을 향상하는 테스트 
* 설계 도구로써의 테스트 

### 1.1.1 더 좋은 테스트를 작성하기 위한 현황 점검 
* 테스트는 단순 오류 예방 목적뿐 아니라, 코딩 전에 그 코드에 기대하는 동작을 정의하는 설계 보조 수단으로까지 활용한다.
* 구현까지 끝나야 검증을 시작하는게 아니라 애초에 설계부터 검증하고 들어가는 것이다.
* 자동화된 테스트는 생산성을 높이고 개발 속도를 빠른 상태로 유지해준다.

#### JUnit in Action이라는 책 추천 

### 1.1.2. 테스트의 가치 
#### 테스트는 실수를 바로잡아준다. 
간단한 단위 테스트로 버그를 바로 잡음 

#### 100% 코드 커버리지 달성이 중요한 게 아니다.
100%가 되어도 버그가 없다는 것을 보장해주는 것이 아니다.

#### 테스트는 실사용에 적합한 설계를 끌어내준다.
실패할 게 뻔한 테스트를 먼저 만들고, 그 테스트가 성공할 만큼의 코드를 작성했다.
-> 나의 테스트 코드는 이러한 조건을 만족하지 않음. 구현 내용 상관없이 성공하는 테스트랄까?

#### 테스트는 원하는 동작을 명확히 알려주어 군더더기(gold-plating)를 없애준다.
테스트가 단순한 품질 보증이나 실수 재발 방지 수단만이 아니다.

#### 테스트를 작성해서 얻게 되는 가장 큰 수확은 테스트 자체가 아니다. 작성 과정에서 얻는 깨달음이다. **품질 고지**와 **설계 고지**에 도달하자

### 1.2.1 생산성에 영향을 주는 요소 
테스트 코드를 허투루 작성하고 문제를 심어 놓으면, 나중에 발목 잡힐 날이 온다.
중복도 많고 쓸데없이 복잡한 테스트 코드는 생산성을 떨어뜨리고 테스트의 긍정적 효과마저 앗아간다.

**테스트 실행 속도**는 변경사항을 검증하고 확인하기 위해 기다리는 시간에 직결된다.
**테스트 결과의 정확도**는 테스트가 약속한 것은 확실히 잡아내고, 몇 번을 수행해도 항시 같은 결과가 나와야 한다 


생산성에 직접 영향을 주는 요소 
* 피드백 주기 
* 디버깅 시간 

-----
NOTE 버그 수정 비용의 증가 
구글이 측정한 결함 수정 비용(XP Day 2009)

버그를 만들자 마자 즉시 수정 $5
프로젝트 전체 빌드 때 발견하면 $50
통합 테스트까지 살아남으면 $500
시스템 테스트에 이르면 $5000

-----

### 1.2.2 설계 잠재력 곡선 
테스트의 잠재 가치를 전부 끌어내고 싶다면 
1. 테스트 코드도 제품 코드를 다루듯 하라. 믿고 의지할 수 있을 만큼 철저하게 리팩토링하고 높은 품질을 유지하라.
2. 테스트를 제품 코드가 목적과 쓰임새에 적합한 구조가 되게끔 이끌어주는 설계 수단으로 활용하라.

## 1.3 설계 수단으로써의 테스트 
테스트의 목적은 
1. 즉시 코드가 정상적으로 동작하는지 검사하는 것
2. 코드베이스가 커져도 잘 동작하는지 지속해서 확인하는 것

테스트를 코드 설계용으로 사용하면
설계 -> 코딩 -> 테스트의 순서가 
테스트 -> 코딩 -> 설계 순서로 바뀐다. 마지막 설계 단계는 테스트 -> 코딩 -> 리팩토링이름이 된다.

### 1.3.1 테스트 주도 개발 
코드가 갖춰야 할 기능을 명시하는, 실패하는 테스트 없이는 코드를 작성하지 않는다.

# 3. 테스트 더블 
* 테스트 더블로 할 수 있는 일 
* 테스트 더블의 종류
* 테스트 더블을 효과적으로 활용하기 위한 지침 

테스트하려는 코드를 주변에서 분리하는 것이 테스트 더블을 활용하는 가장 기본적인 이유다.
스텁(stub)과 더미(dummy)는 제품 코드가 온전히 준비되기 전까지 사용할 대용품
속도를 개선하고, 예측 불가능한 요소를 제어하고, 특수한 상황을 시뮬레이션하고, 감춰진 정보를 얻어내는 등의 용도로까지 쓰임 

### 3.1.1 테스트 대상 코드를 격리한다
테스트 대상 코드를 격리한다

* 테스트 대상 코드 
* 테스트 대상 코드와 상호작용하는 코드 

### 3.1.2 테스트 속도를 개선한다 
테스트 더블로 협력 객체를 대체하면 원본을 그대로 사용할 때보다 빨라진다 

### 3.1.3 예측 불가능한 실행 요소를 제거한다 

### 3.1.4 특수한 상황을 시뮬레이션한다 
객체를 적절히 초기화해서 인자로 넣어주기만 해도 원하는 거의 모든 상황을 만들어낼 수 있다. 

### 3.1.5 감춰진 정보를 얻어낸다 

## 3.2 테스트 더블의 종류 
테스트 더블의 종류
* 테스트 스텁 
* 가짜 객체 
* 테스트 스파이 
* Mock 객체 

### 3.2.1 테스트 스텁은 유난히 짧다 
* 스텁 : 원래의 구현을 최대한 단순한 것으로 대체하는 것. 끝이 잘렸거나 유난히 짧은 것

### 3.2.2 가짜 객체는 뒤끝 없이 처리한다 
UserRepository가 실제 db에 접근하지 않고 가져올 수 있도록 구현한다 

### 3.2.3 테스트 스파이는 기밀을 훔친다 
Spy 객체를 넣어서 원하는 것을 테스트한다 

### 3.2.4 Mock 객체는 예기치 않은 일을 막아준다 
Mock 객체는 특수한 형태의 테스트 스파이다. 

## 3.3 테스트 더블 활용 지침 
### 3.3.1 용도에 맞는 더블을 선택하라 
### 3.3.2 준비하고, 시작하고, assert하라 
### 3.3.3 구현이 아니라 동작을 확인하라 
### 3.3.4 자신의 도구를 선택하라 

## 3.4 요약
테스트 더블은 테스트 스텁, 가


# Part 2 테스트 냄새 
테스트 코드에 기생하는 문제를 식별하고 수정하는 능력을 길러보자. 
가독성, 유지보수성, 신뢰성을 떨어뜨리는 속성이나 특징 등, 테스트 코드를 작성하면서 자주 맡을 수 있는 '테스트 냄새'를 나열한 목록이다.

* 4장 테스트의 가독성을 떨어뜨리는 냄새 
* 5장 유지보수 어렵게 하는 냄새 
* 6장 변덕이 심해서 신뢰할 수 없는 테스트 냄새 

# Chapter 4 가독성 
테스트를 읽은 프로그래머는 코드가 해야 할 일을 이해할 수 있어야한다. 

## 4.1. 기본 타입 assert 
assert는 가정이나 의도를 명시해야 한다. 또한 코드의 동작을 서술하는 문장이어야 한다. 

### 4.1.2 개선 방법 
assert 대상의 추상화 수준이 너무 낮다 
assertThat(out.indexOf("test.txt:1 1st match"), is(not(-1)));

## 4.2 hyperassertion 
검사하려는 동작의 아주 작은 하나까지도 놓치지 않으려는 집착의 산물이다.
하나만 잘못되어도 바로 실패하기 때문에, 본래 의도했던 것도 그 광활한 검증 범위에 묻혀 희석된다. 

너무 두터운 안정장치이다. 

**테스트가 실패하는 이유는 오직 하나뿐이어야 한다.**

### 4.2.2 개선 방법 
우선 테스트를 나눠라 

## 4.3 비트 단언 

### 4.3.1 예시 

### 4.4.2 개선 방법
테스트의 핵심은 정면 한가운데 있어야 하는데, 

* 핵심이 아닌 설정은 private()나 setup()으로 추출하라.
* 적절한 인자와 서술형 이름을 사용하라
* 한 메서드 안에서는 모두 같은 수준으로 추상화하라 

### 4.5 다중 인격(split personality)

데이터나 로직을 언제 통합(inline)해야 할까?
1. 짧다면 통합하라.
2. 통합하기에 너무 길다면 팩토리 메서드나 테스트 데이터 생성기를 통해 만들어라 
3. 이마저도 쉽지 않다면 그냥 독립 파일로 남겨둬라.

## 4.8 setup 설교 
### 4.8.1 예시 
### 4.8.2 개선 방법 
1. 셋업에서 핵심을 제외한 상세 정보는 private 메서드로 추출한다.
2. 알맞은 서술적 이름을 사용한다.
3. 셋업 내의 추상화 수준을 통일한다. 

## 4.9 과잉보호 테스트 
### 4.9.2 개선 방법 
test에서는 null인지 검사할 필요 없음 

# Chapter 5 유지보수성 
* 인지 부하를 가중시키는 테스트 냄새 
* 유지보수 악몽에 시달리게 하는 테스트 냄새 
* 불규칙한 실패를 초래하는 테스트 냄새 

## 5.1 중복 
모든 악의 근원 

* 어설픈 최적화 
* 중복 

### 5.1.2 개선방법 
1. 상수 중복 -> 지역 변수로 
2. 구조 중복 -> 구조적 중복을 추출하여 사용자 정의 assert 메서드로 밀어 넣는다 

## 5.2 조건부 로직(conditional logic)
conditional logic을 포함하는 테스트는 제 역할을 못할 가능성이 높다.

